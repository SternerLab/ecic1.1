library(magrittr)


# GenerateData -----------------------------------------------------------------
#' Generate a sample from a fitted model
#'
#' @param n: Sample size.
#' @param true: A string giving the name of the model to generate data from.
#' @param param: A vector of parameters specifying a fitted true model.
#' @param best: A string giving the name of the model to be given as best.
#' @param models: A string vector of model names for selecting between.
#' @param N: Number of bootstrap samples.
#' @param ic: String giving which information criterion to use (e.g. 'AICc', 'BIC')
#
#' @return: A list containing the following:.
#'
#' @examples
#' GenerateData(25, "norm", c(mu = 0.3, sd = 1.2))
#'
#' @export
GenerateData <- function(n, model, param){
  # Computes the log-likelihood and fitted parameters for a dataset and a model.
  #
  # Args:
  #   data:  compatible with the specified model.
  #   n: Sample size.
  #   model: A string specifying the model to compute the log-likehood for
  #   compress: A boolean specifying if output should be of list or vector type
  #
  # Returns:
  #   A vector/matrix data sample generated by the given model.
  do.call(paste("GenerateData.", model, sep = ""),
          list('n' = n, 'model' = model, 'param' = param))
}
#' @export
GenerateData.norm0 <- function(n, model, param){
  # Computes the log-likelihood and fitted parameters for a dataset and a model.
  #
  # Args:
  #   data:  compatible with the specified model.
  #   n: Sample size.
  #   model: A string specifying the model to compute the log-likehood for.
  #   compress: A boolean specifying if output should be of list or vector type
  #
  # Returns:
  #   A vector/matrix data sample generated by the given model.
  rnorm(n, 0, 1)
}
#' @export
GenerateData.norm1 <- function(n, model, param){
  # Computes the log-likelihood and fitted parameters for a dataset and a model.
  #
  # Args:
  #   data:  compatible with the specified model.
  #   n: Sample size.
  #   model: A string specifying the model to  compute the log-likehood for.
  #   compress: A boolean specifying if output should be of list or vector type.
  #
  # Returns:
  #   A vector/matrix data sample generated by the given model.
  rnorm(n, param[1], 1)
}
#' @export
GenerateData.norm <- function(n, model, param){
  # Computes the log-likelihood and fitted parameters for a dataset and a model.
  #
  # Args:
  #   data:  compatible with the specified model.
  #   n: Sample size.
  #   model: A string specifying the model to compute the log-likehood for.
  #   compress: A boolean specifying if output should be of list or vector type
  #
  # Returns:
  #   A vector/matrix data sample generated by the given model.
  rnorm(n, param[1], param[2])
}
#' @export
GenerateData.rwalk <- function(n, model, param){
  # Computes the log-likelihood and fitted parameters for a dataset and a model.
  #
  # Args:
  #   data:  compatible with the specified model.
  #   n: Sample size.
  #   model: A string specifying the model to compute the log-likehood for.
  #   compress: A boolean specifying if output should be of list or vector type.
  #
  # Returns:
  #   A vector/matrix data sample generated by the given model.
  cumsum(rnorm(n, param[1], param[2]))
}
#' @export
GenerateData.rwalk0 <- function(n, model, param){
  # Computes the log-likelihood and fitted parameters for a dataset and a model.
  #
  # Args:
  #   data:  compatible with the specified model.
  #   n: Sample size.
  #   model: A string specifying the model to compute the log-likehood for.
  #   compress: A boolean specifying if output should be of list or vector type
  #
  # Returns:
  #   A vector/matrix data sample generated by the given model.
  cumsum(rnorm(n, 0, param[1]))
}
#' @export
GenerateData.spanos1 <- function(n, model, param){
  # Computes the log-likelihood and fitted parameters for a dataset and a model.
  #
  # Args:
  #   data:  compatible with the specified model.
  #   n: Sample size.
  #   model: A string specifying the model to compute the log-likehood for.
  #   compress: A boolean specifying if output should be of list or vector type
  #
  # Returns:
  #   A vector/matrix data sample generated by the given model.
  a0 <- param[1]
  a1 <- param[2]
  sd <- param[3]
  x <- spanos.x
  return(a0+(a1*x) + rnorm(n, 0, sd))
}
#' @export
GenerateData.spanos2 <- function(n, model, param){
  # Computes the log-likelihood and fitted parameters for a dataset and a model.
  #
  # Args:
  #   data:  compatible with the specified model.
  #   n: Sample size.
  #   model: A string specifying the model to compute the log-likehood for.
  #   compress: A boolean specifying if output should be of list or vector type.
  #
  # Returns:
  #   A vector/matrix data sample generated by the given model.
  b0 <- param[1]
  b1 <- param[2]
  b2 <- param[3]
  b3 <- param[4]
  sd <- param[5]
  x <- spanos.x
  return(b0 + (b1*x) + (b2 * x^2) + (b3 * x^3) + rnorm(n, 0, sd))
}
#' @export
GenerateData.spanos3 <- function(n, model, param){
  # Computes the log-likelihood and fitted parameters for a dataset and a model.
  #
  # Args:
  #   data:  compatible with the specified model.
  #   n: Sample size.
  #   model: A string specifying the model to compute the log-likehood for.
  #   compress: A boolean specifying if output should be of list or vector type
  #
  # Returns:
  #   A vector/matrix data sample generated by the given model.
  b0 <- param[1]
  b1 <- param[2]
  b2 <- param[3]
  sd <- param[4]
  x <- spanos.x
  return(b0 + (b1*x) + (b2 * x^2) + rnorm(n, 0, sd))
}



# Generate multiple data samples -----------------------------------------------
#' Generate multiple samples from a fitted model
#'
#' @param n: Sample size.
#' @param true: A string giving the name of the model to generate data from.
#' @param param: A vector of parameters specifying a fitted true model.
#' @param best: A string giving the name of the model to be given as best.
#' @param models: A string vector of model names for selecting between.
#' @param N: Number of bootstrap samples.
#' @param ic: String giving which information criterion to use (e.g. 'AICc', 'BIC')
#
#' @return: A list containing the following:.
#'
#' @examples
#' GenerateData(25, "norm", c(mu = 0.3, sd = 1.2))
#' @export
GenerateDataMulti <- function(n, model, param, N){
  fnc <- paste("GenerateDataMulti.", model, sep = "")
  tryCatch({
    do.call(fnc, list(n = n, model = model, param = param, N = N))
    })
}
#' @export
GenerateDataMulti.norm0 <- function(n, model, param, N){
  rnorm(n * N, 0, 1) %>%
    matrix(ncol = N)
}
#' @export
GenerateDataMulti.norm1 <- function(n, model, param, N){
  rnorm(n * N, param[1], 1) %>%
    matrix(ncol = N)
}
#' @export
GenerateDataMulti.norm <- function(n, model, param, N){
  rnorm(n * N, param[1], param[2]) %>%
    matrix(ncol = N)
}
#' @export
GenerateDataMulti.rwalk <- function(n, model, param, N){
  rnorm(n * N, param[1], param[2]) %>%
    matrix(ncol <- N) %>%
    apply(2, cumsum)
}
#' @export
GenerateDataMulti.rwalk0 <- function(n, model, param, N){
  rnorm(n * N, 0, param[1]) %>%
    matrix(ncol = N) %>%
    apply(2, cumsum)
}
#' @export
GenerateDataMultiOld <- function(n, model, param, N){
  if (model == "norm2")
    return(rnorm(n*N, param[1], param[2]) %>% matrix(ncol <- N))
  if (model == "norm0")
    return(rnorm(n*N, 0, 1) %>% matrix(ncol <- N))
  if (model == "norm1")
    return(rnorm(n*N, param[1], 1) %>% matrix(ncol <- N))
  if(model == "uwalk"){
    steps <- rnorm(n*N, 0, param[1]) %>% matrix(ncol <- N)
    return(apply(steps, 2, cumsum))
  }
  if(model == "gwalk"){
    steps <- rnorm(n*N, param[1], param[2]) %>% matrix(ncol <- N)
    return(apply(steps, 2, cumsum))}
  if (model == "GRW"){
    anc <- param$Parameters[[1]]
    ms  <- param$Parameters[[2]]
    vs  <- param$Parameters[[3]]
    vv  <- param$vv[1]
    nn  <- param$nn
    return(lapply(1:N, function(x) sim.GRW(n, ms, vs, vv, nn)))
  }
  if (model == "URW") {
    anc <- param$Parameters[[1]]
    vs  <- param$Parameters[[2]]
    vv  <- param$vv[1]
    nn  <- param$nn
    return(lapply(1:N, function(x) sim.GRW(n, ms, vs, vv, nn)))
  }
  if (model == "Stasis"){
    theta  <- param$Parameters[[1]]
    omega  <- param$Parameters[[2]]
    vv  <- param$vv[1]
    nn  <- param$nn
    return(lapply(1:N, function(x) sim.Stasis(n, theta, omega, vv, nn)))
  }
  if (model == "seg") return(sapply(1:N, function(x) GenerateData(n, "seg", param)))
  if (model == "seg2") return(sapply(1:N, function(x) GenerateData(n, "seg2", param)))
  if (model == "smooth") return(sapply(1:N, function(x) GenerateData(n, "smooth", param)))
  if (model == "smooth2") return(sapply(1:N, function(x) GenerateData(n, "smooth2", param)))
  if (model == "lm1") return(sapply(1:N, function(x) GenerateData(n, "lm1", param)))
  if (model == "lm2") return(sapply(1:N, function(x) GenerateData(n, "lm2", param)))
  if (model == "lm3") return(sapply(1:N, function(x) GenerateData(n, "lm3", param)))

}

# Generate data samples with a given best performing model ---------------------
#' Generate multiple samples from a fitted model with specified best performing
#' model
#'
#' @param n: Sample size.
#' @param true: A string giving the name of the model to generate data from.
#' @param param: A vector of parameters specifying a fitted true model.
#' @param best: A string giving the name of the model to be given as best.
#' @param models: A string vector of model names for selecting between.
#' @param N: Number of bootstrap samples.
#' @param ic: String giving which information criterion to use (e.g. 'AICc', 'BIC')
#
#' @return: A list containing the following:.
#'
#' @examples
#' GenerateData(25, "norm", c(mu = 0.3, sd = 1.2))
#' @export
GenerateDataBest <- function(n, true, param, best,models, N, ic = 'AIC', ...){
  check <- GenerateData(n, true, param)
  if(is.numeric(check)){
    mins <- 0
    best.ix <- which(models==best)
    it1 <- 0
    nonzero <- FALSE
    while(!(best.ix %in% mins) &  it1 < 1000){
      data <- GenerateDataMulti(n, true, param, N*3)
      scores <- ICMultiMulti(data, models, ic)$ic
      mins <- apply(scores,1,which.min)
      data.best2 <- as.matrix(data[,mins==best.ix])
      if(best.ix %in% mins) nonzero <- TRUE
      it1 <- it1 + N
    }
    if(!nonzero)return(0)
    it <- 0
    while(dim(data.best2)[2] < N & it < 4){
      data <- GenerateDataMulti(n, true, param, N*3)
      scores <- ICMultiMulti(data, models, ic)$ic
      mins <- apply(scores,1,which.min)
      data.best <- data[,mins==best.ix]
      data.best2 <- cbind(data.best2, data.best)
      it <- it + 1
    }
    if(dim(data.best2)[2] > N) out <- as.matrix(data.best2[,1:N])
    if(dim(data.best2)[2] <= N) out <- as.matrix(data.best2)
    return(out)}
}
